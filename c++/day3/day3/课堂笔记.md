## 1、static成员

```c
1、static修饰对象，如果是局部对象，则延长生命周期；如果是全局对象，则限制只能在当前文件使用。
2、static修饰成员变量
    目的：设置与具体对象无关的成员变量，该静态成员变量属于 类本身。在同类型的对象之间可进行数据传递。
    注意：
    	1、静态成员变量必须在类体之外进行定义初始化。
    		数据类型 类名::变量名 = 初值;
		2、静态成员变量的使用(前题该 成员为公有权限)
            对象.静态成员变量
            类名::静态成员变量
3、static修饰成员函数
   函数声明时：
      static 数据类型 函数名(<形参列表>);
   函数类体外定义时：
       数据类型 类名::函数名(<形参列表>)
       {
           
       }
	注意：
        1、静态成员函数与具体对象无关，属于类本身
        2、静态成员函数没有 this指针，因此只能访问类的静态成员。
```

## 2、const成员

```c
1、const修饰成员变量：
    1、对象的该属性只可读，不可修改。
	2、const成员变量必须使用构造函数初始化列表 进行初始化
2、const修饰成员函数：
    1、目的表示通过该函数不会修改任何成员变量，只能访问成员变量。
    2、const成员函数声明 和 定义末尾都必须加 const修饰
    3、C++默认成员函数都可修改成员变量，const成员函数只能调用const成员函数。
3、const修饰类对象：
    1、目的：表示该对象只可读
    2、const对象只能调用 const成员函数
    3、const对象能访问非公有的const成员变量，但不能修改。
```

## 3、friend友元

```c
1、为什么使用友元？
    由于类的封装，如果程序平凡访问操作成员变量，只能通过成员函数进行。访问操作成员函数需要对函数类型、参数类型、访问权限(安全性)进行检查，这样就会导致大量的系统时间开销，影响程序效率。
    为了提升程序的效率，采用友元，来打破类的封装。
    
2、友元的分类：
    1、友元函数
    	1、在类体中用 friend声明一个函数，那这个函数就是友元函数。友元函数不是类的成员函数
    	2、友元函数在类外部定义时，就是一个普通函数的定义。
    	3、友元函数的使用，就是普通函数的使用。
    	4、友元函数打破该类的封装，在函数体中可以通过对象 访问 类的任何成员。
    2、友元类
    	友元关系：
    		1、友元关系不能被继承。
    		2、友元关系不能被传递。
    		3、友元关系不是相互的，除非单独说明。
    	1、在A类中声明B类为友元，那么B就是A的友元类，B类的所有成员函数都将打破A类的封装。
    	
    3、友元成员函数
    	1、在A类中，声明B的某个成员函数为友元，那该函数就是友元成员函数，B类的该成员函数才会打破A类的封装。
```

