## 1、C++与C语言的差异性

### 1、严格的类型检查

```c
const int a = 12;
// int *p = &a;			//错误,不允许将 const 隐式转换为 非const
int *p = (int *)&a;
```

### 2、const修饰变量

```c
const修饰的变量为只读变量。
    const int a = 12;			//const修饰变量为只读变量
	int *p = (int *)&a;
	*p += 12;
	cout << a << endl;  ==> a: 12
```

### 3、类型的转换

```c
int a = (int )13;
int b = int(14);
```

### 4、引用

```c
1、是一种新的数据类型			数据类型&
2、实质：为变量取别名
3、引用类型定义必须 初始化，一旦绑定变量，后续不可修改。
	int a = 13;
	int &p = a;
4、任何一个变量都可以取别名。
5、左值引用 和 右值引用：
	左值：变量即可在等号左侧，也可以在右侧。
		int a = 12;
		int& p = a;
	右值：常数、临时变量(对象)，也就是只能出现在等号右侧。
		int&& p = 13;
		int&& q = move(a);
	const修饰的引用：
        const int& p = 13;

6、函数的参数传递：值传递、地址传递、引用传递。
    
好处？
    避免额外空间的消耗。提升程序运行效率。
```

### 5、重载

```c
1、重载关系(overload)
    1、函数名相同
    2、返回值不管
    3、参数列表不同(参数个数不同、参数类型不同)
```

### 6、默认参数

```c
1、函数声明式，可以设置形参的初始值。定义时不能设置。
2、一个形参被设置默认参数，其右边的所有形参都必须设置 默认参数。
3、函数调用时，从左往右赋值形参，默认参数可以不传实参。
4、默认参数与函数重载同时出现，当函数调用时，小心歧义。
```

### 7、内联函数

```c
1、函数功能简单，代码量少，结构单一不能有for循环等结构语句
2、内联函数必须是要频繁使用的函数，为了提升程序的运行效率
3、内联函数由关键字 inline 说明，在函数声明时说明,编译阶段就将函数的主体代码，替换到函数调用的地方。
	inline int add(int x, int y);  //声明一个内联函数
	int add(int x, int y)
    {
        return x+y;
    }
```

### 8、结构体

```c
1、一种用户自定义的数据类型，用来描述一个复杂的事物。
    struct 结构体名{
        //成员变量1
        //成员变量2
        // ....
    };
```

### 9、内存模型及名字空间
## 类和对象

#### 1、类

```c
代码角度：一个用户自定的数据类型，类似于C语言的结构体。由关键字 class说明。
抽象角度：对象的类型，描述一批具有相同属性和行为的对象。
```

#### 2、对象

```c
代码角度：就是一个类类型的变量。
抽象角度：万事万物皆为对象。凡是具备 属性和行为两要素的事物都被称为对象。
```

#### 3、构造函数

```c
构造函数：用来初始化对象的特殊成员函数。在定义类对象时，系统自动调用。
构造函数语法：
	1、没有数据类型，没有返回值。
    2、函数名必须与类名相同。
当类体中，没有定义构造函数，编译自动生成默认构造。
    类名(){  //默认构造
    
	}
	类名(类名& ){ //拷贝构造
        // 浅拷贝
        // 深拷贝
    }
	类名(类名&& ){ //移动构造
        //资源转移
        //移交拥有的权限
    }
例如：
	class Student{
        
    };

	使用：
        Student stu;		//默认构造
		Student stu1 = stu; //拷贝构造
		Student Stu2(stu1); //拷贝构造
		Student Stu3 = move(stu); //移动构造
		Student stu4(12);   //有参构造
		Student stu5 = 12;  //有参构造

		Student *p;
		p = &stu;			//地址运算

		stu5 = stu;			//赋值运算
		
		p = new Student;		//默认构造
		p = new Student(12);	//有参构造
```

#### 4、深浅拷贝

```c
浅拷贝： 同类型的对象的 成员指针指向同一个堆区。对象的内容会相互影响。
深拷贝： 同类型的对象的 成员指针指向不同堆区。对象的内容互不影响。
```

#### 5、析构函数

```c
析构函数：用来回收对象资源的特殊成员函数。对象生命周期结束，或者delete 时，系统自动调用。

~类名()
{
    
}
1、没有数据类型，没有返回值
2、~加类名构造析构函数名
3、空参数
```

#### 6、this指针

```c
1、特殊的成员指针，用来区分 形参名 与 成员变量同名。
2、类的所有成员函数都有 this指针
3、this指针指向当前类对象。
```

### 7、OOP思想

```c
1、OOP思想之抽象
    抽象是对具体对象（问题）进行概括，描述出这一类对象的公共性质。
    数据抽象：描述某类对象的属性或状态（对象相互区别的物理量）。
    代码抽象：描述某类对象的共有的行为特征或具有的功能。
    抽象的实现：通过类的定义。
    
2、OOP思想之封装
    将抽象出的数据成员、代码成员相结合，将它们视为一个整体。目的是增强安全性和简化编程，使用者不必了解具体的实现细节，而只需要通过外部接口，以特定的访问权限，来使用类的成员。实现封装：其表现形式类定义中的：{ }
    
3、OOP思想之分类
    层层分类，使概念逐渐细化、具体化。例如，生物分为动物和植物，动物又分为脊椎动物和无脊椎动物，脊椎动物包括哺乳动物，哺乳动物又分为猫、狗……，等等。
    
4、OOP思想之继承
    子类继承父类所有的属性、方法，并可定义自己的特有属性与方法。提高软件开发效率，为“软件重用”(software reusability)提供强有力的支持。
    
5、OOP思想之多态
    C++中的多态性(polymorphism) ： 由继承而产生的相关的不同的类，其对象对同一消息会作出不同的响应。多态性是面向对象程序设计的一个重要特征，能增加程序的灵活性。

```
## 1、static成员

```c
1、static修饰对象，如果是局部对象，则延长生命周期；如果是全局对象，则限制只能在当前文件使用。
2、static修饰成员变量
    目的：设置与具体对象无关的成员变量，该静态成员变量属于 类本身。在同类型的对象之间可进行数据传递。
    注意：
    	1、静态成员变量必须在类体之外进行定义初始化。
    		数据类型 类名::变量名 = 初值;
		2、静态成员变量的使用(前题该 成员为公有权限)
            对象.静态成员变量
            类名::静态成员变量
3、static修饰成员函数
   函数声明时：
      static 数据类型 函数名(<形参列表>);
   函数类体外定义时：
       数据类型 类名::函数名(<形参列表>)
       {
           
       }
	注意：
        1、静态成员函数与具体对象无关，属于类本身
        2、静态成员函数没有 this指针，因此只能访问类的静态成员。
```

## 2、const成员

```c
1、const修饰成员变量：
    1、对象的该属性只可读，不可修改。
	2、const成员变量必须使用构造函数初始化列表 进行初始化
2、const修饰成员函数：
    1、目的表示通过该函数不会修改任何成员变量，只能访问成员变量。
    2、const成员函数声明 和 定义末尾都必须加 const修饰
    3、C++默认成员函数都可修改成员变量，const成员函数只能调用const成员函数。
3、const修饰类对象：
    1、目的：表示该对象只可读
    2、const对象只能调用 const成员函数
    3、const对象能访问非公有的const成员变量，但不能修改。
```

## 3、friend友元

```c
1、为什么使用友元？
    由于类的封装，如果程序平凡访问操作成员变量，只能通过成员函数进行。访问操作成员函数需要对函数类型、参数类型、访问权限(安全性)进行检查，这样就会导致大量的系统时间开销，影响程序效率。
    为了提升程序的效率，采用友元，来打破类的封装。
    
2、友元的分类：
    1、友元函数
    	1、在类体中用 friend声明一个函数，那这个函数就是友元函数。友元函数不是类的成员函数
    	2、友元函数在类外部定义时，就是一个普通函数的定义。
    	3、友元函数的使用，就是普通函数的使用。
    	4、友元函数打破该类的封装，在函数体中可以通过对象 访问 类的任何成员。
    2、友元类
    	友元关系：
    		1、友元关系不能被继承。
    		2、友元关系不能被传递。
    		3、友元关系不是相互的，除非单独说明。
    	1、在A类中声明B类为友元，那么B就是A的友元类，B类的所有成员函数都将打破A类的封装。
    	
    3、友元成员函数
    	1、在A类中，声明B的某个成员函数为友元，那该函数就是友元成员函数，B类的该成员函数才会打破A类的封装。
```
## 1、为什么使用运算符重载？

```c
C++的运算符，支持的操作类型默认为 基本的内置类型，不支持用户自定义类型。某个特殊情况需要自定义类型的数据也要进行相应的运算。
那么就需要对这些 运算符进行重载，赋予运算符新的功能。
```

## 2、运算符重载

```c
1、运算符重载的实质是 函数重载。
2、语法规则：
    数据类型 operator<运算符>(<形参列表>)
	{
    	函数体;
	}
	
	注意：
        1、运算符重载函数，必须声明在 自定的类型中
        2、运算符重载函数，既可以是成员、也可以是友元函数
3、不能被重载的运算符
   点号运算符. 、三目运算符 ?、sizeof运算符、作用域访问符 ::
```

## 3、友元运算符重载

```c
class 类名{
public:
	friend 数据类型 operator<运算符>(<形参列表>);
};
注意：
    1、友元运算符重载函数的形参个数 = 运算符操作数个数。
    2、为了区分前 ++ 和 后 ++，后++的运算符重载函数得参数int类型占位
```

## 4、成员运算符重载

```
class 类名{
public:
	数据类型 operator<运算符>(<形参列表>);
};
注意:
	1、成员运算符重载函数第一参数拥有 this指针，指向运算符的第一操作数这个自定义类型的对象
	2、成员运算符重载函数形参个数 = 运算符操作数个数 - 1
```

## 5、如何选择 友元 运算符重载还是 成员 运算符重载？

```c
1、如果运算符的第一操作数 不是自定义类型，那必须只能使用  友元运算符重载。
2、()运算符的重载函数只能选择 成员函数运算重载。
```

## 6、函数返回值问题？

```c
1、一般而言，函数的数据类型就是函数返回值类型。
2、类的成员函数 返回成员变量，并外部通过该返回值修改成员变量内容，则函数返回 引用类型。
```
## 1、什么是模板

```C
1、C++中的模板是参数多态化的工具，就是让函数或者类声明为一种通用类型。让类的某些数据成员和成员函数参数、返回值在实际使用时可以是任意类型。
2、目的：让程序员编写与类型无关的代码，是泛型编程的基础。
3、分类：
	函数模板：
		针对功能相近，参数类型类型不同的函数。
	类模板：
		针对数据成员类型 和 成员函数参数、返回值类型不同的类。
    
   	注意：
    	模板的声明只能在全局、名字空间、类域中。绝不能在局部。
```

## 2、函数模板

```cpp
1、声明的语法结构：
    template <模板参数列表> 数据类型 函数名(<形参列表>);  //声明一个函数模板
	
	或：
		template <模板参数列表> 
    	数据类型 函数名(<形参列表>);

2、定义的语法结构：
    template <模板参数列表>  数据类型 函数名(<形参列表>)
	{
    	//函数体
	}

3、使用的方法：
    1、隐式调用，编译器自动适配参数类型
    	函数名(<实参列表)
   	2、显示调用，编译器自动适配参数类型
    	函数名<>(实参列表);
	3、显示调用，指定数据类型
        函数名<数据类型>(实参列表);

4、模板形参被编译器在编译阶段进行实例化。
5、函数模板在编译阶段被编译器在代码中，定义多份。
```

## 3、类模板

```cpp
1、类模板的定义
    template <class T>
    class Demo{
    public:
        Demo(T x);
        void setValue(T x);
        T getValue();
    private:
        T x;
    };
2、类模板成员函数类体之外的定义
    template <class B> Demo<B>::Demo(B x) : x(x)
    {
    }
    template <class T> void Demo<T>::setValue(T x)
    {
        this->x = x;
    }
    template <class C>
    C Demo<C>::getValue()
    {
        return x;
    }
3、类模板的使用
    Demo<int> obj(12);
	obj.setValue(13);

注意：
    1、类模板的成员函数在类体之外定义，每一个都必须使用 template<形参列表> 单独定义。
    2、如果一个类为模板，那么该类的所有成员函数都是 函数模板。反之却不一定。
    3、类模板的使用，必须显示使用并指定 数据类型。
```
## 1、类的继承

```c
1、概念：
	在已存在的类基础上创建一个新的类，就是 继承。
	已有的类称为： 基类 或者 父类
	新建的类称为： 派生类 或者 子类
	兄弟类： 同一基类的多个子类。
	最远派生类：关系最远的派生类
	
2、父类和子类 是相对的。

3、继承和派生现象
	类的继承：一个新的类从已有类获得其已有特性，这种现象。
	类的派生：从已有类（父类）产生一个新的子类，这种现象。
	
4、派生类 几乎 继承了基类的所有数据成员 和 成员函数。
```

## 2、派生一个类

```cpp
基本语法：
	class 子类名 : 权限访问限定符  基类名1,权限访问限定符  基类名2,...
    {
    	//class body
    };
1、公有继承时：派生类对象只能访问基类 public成员,派生类内部(成员函数)只能访问基类 public/protected成员。 
2、保护继承时：派生类对象不能访问基类    任何成员,派生类内部(成员函数)只能访问基类 public/protected成员。 
3、私有继承时：派生类对象不能访问基类    任何成员,派生类内部(成员函数)只能访问基类 public/protected成员。
    
4、 基类和派生类有同名成员，在派生类基类的同名成员将被隐藏。
    派生类访问基类被隐藏的成员： 基类名::成员名
    	派生类内部：Base::x
    	派生类对象：obj.Base::x	
```

## 3、单继承

```cpp
单继承：基类只有 1个的继承。
    
1、构造顺序：
	先基类构造，再派生类构造
2、析构顺序：
	先派生类析构，在基类析构
    
3、派生类的构造函数初始化列表，默认调用 基类的无参构造函数，来对积累部分进行初始化。
```

## 4、继承的关系

```
1、is-a关系：公有继承，基类对象能做的任何事，派生类对象也可以。
	描述：水果是基类，苹果是派生类。苹果一种特定水果。
	
2、has-a关系：聚合包含关系。一个类中有另一类对象作为成员。
	派生类对象的构造顺序： 析构顺序与之相反。
		先基类构造，再成员对象构造，最后派生类构造
3、is-implemented-a关系：作为 ... 来实现.
4、is-like-a关系： 像 ... 一样。
```

## 5、多重继承

```cpp
1、概念：
	一个派生类有多个直接继承的基类。
2、语法结构
	class 子类名 : 权限访问限定符  基类名1,权限访问限定符  基类名2,...
    {
    	//class body
    };
    
3、多重继承的构造、析构顺序
	构造顺序：
		左起第一基类构造，左起第二基类构造,  ...派生类构造
	析构顺序：
		与构造顺序相反
4、当多重继承的基类有同名成员，
	派生类对象访问成员 会出现 歧义，名字二义性。
	解决方式：
		作用域访问符
```

## 6、多层继承

```cpp
1、概念：
	至少有爷孙关系的继承。
2、语法结构：
	class Worker{};
	class Signer : public Worker{};
	class Writer : public Worker{};
	class SingerWriter : public Signer, public Writer{};
3、最远派生类对象访问顶层基类成语：
	容易出现歧义，路径二义性。
	解决方式：
		1、作用域访问符
		2、设置虚基类
4、虚基类：
	虚继承的共同基类。虚基类在内存中只会构造一份。

5、虚继承：
	继承时使用 virtual关键字修饰。
	
6、多重继承时，如果有虚继承：
	构造顺序：
		先虚继承的基类构造，再左起第一基类构造 ... 派生类构造
```
## 1、多态

```cpp
一个接口，多种方法。程序在运行时才决定调用的函数，是面向对象编程的核心概念。
```

## 2、多态性

```cpp
将接口与实现进行分离。实现以共同的方法，但因个体差异的不同，采取不同策略。
```

## 3、OOP主要特征

```cpp
1、封装：wrap 实现细节的隐藏，是代码模块化。就是类的设计。
2、继承：inheritance 实现代码的重用。
3、多态：polymorphism，实现了接口的重用。
```

## 4、为什么要有多态？

```cpp
希望子类和基类有相同的方法，但行为却有所不同。
```

## 5、如何实现多态性

```cpp
使用虚函数来实现多态性。基类的函数声明时用 virtual 来修饰。
```

## 6、多态的限制

```cpp
1、非类的成员函数不能设置虚函数
2、类的静态成员不能设置为 虚函数
3、构造函数不能设置为 虚函数，但析构函数可以。
4、基类函数被 virtual修饰，派生类中的同名函数(返回值、函数名、参数列表完全一致)自动成为虚函数。
5、函数声明时用 virtual，定义不需要。
    
    
注意：
    如果一个类被 final 关键字修饰，那么这个类就不能派生出新的类。
```

## 7、三个概念

```cpp
1、覆盖(override)
    也称为重写，指派生类重新定义基类虚函数的功能。
    A、位于不同作用域，基类 和 派生类。
    B、函数返回值、参数列表、函数名完全一致。
    C、基类函数有 virtual 修饰，派生类不管。
2、重载(overrload)
    A、位于同一个类域
    B、函数名相同，参数列表不同，返回值不管
    C、无论有无 virtual 修饰
3、隐藏
    也称为重定义。
    A、位于不同的类域，基类 和 派生类。
    B、函数名相同，返回值不管。
    C、参数相同时，基类函数不能有 virtual 修饰。
    D、参数不同时，无论基类是否有 virtual 修饰。
```

## 8、联编

```cpp
1、联合编译：
    动态联编 和 静态联编。
2、静态联编：
    在程序编译时，就将相关的库、函数，编译到代码中。也称为 早绑定。
3、动态联编
    程序运行时，才决定调用哪个函数。也称为 晚绑定。
```

## 9、虚函数表

```cpp
1、C++引入虚函数表，来实现动态联编，从实现多态性。
2、虚函数表
	内存中，专门存放虚函数首地址的表。
```

## 10、抽象类

```cpp
1、拥有纯虚函数的类，就是抽象类。
2、纯虚函数：纯虚函数只有声明没有定义，函数的功能必须有 派生类实现。
    virtual void func() = 0;		//声明纯虚函数
3、抽象类不能有实例(就是不能定义对象)

4、为什么需要抽象类？
    因为某些类的对象存在是不合理的。比如：图形类、动物类等，都不应该拥有实际的对象。
5、特点：
    1、抽象类没有完整的信息，只能是派生类的基类
	2、抽象类不能有实例，不能有静态成员
	3、派生类应该实现抽象类的所有方法
```

作业：设计一个Graphic图形类，能实现计算 三角形、矩形、圆的面积。

## 11、虚析构函数

```cpp
1、目的是，delete 基类指针时，系统只调用基类析构函数，而不调用派生类析构函数回收资源，造成资源浪费问题。
2、基类析构函数声明之前加 virtual 修饰    
```

## 12、纯虚析构函数

```cpp
1、不知道基类析构函数该回收什么、释放什么资源，那么基类的虚析构函数就应该设置为 纯虚函数。
2、纯虚析构函数：不仅需要声明，也必须进行定义。
   声明：
    virtual ~Base() = 0;
   定义：
    Base:: ~Base(){}
```








